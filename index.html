<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Quantum Christmas V2.0 - æ¢¦å¹»ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-element { position: absolute; top: 0; left: 0; visibility: hidden; }
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-family: 'Arial', sans-serif; pointer-events: none; z-index: 10;
            text-align: center; text-shadow: 0 0 20px rgba(0, 255, 100, 0.5); transition: opacity 1s;
        }
        .instruction {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-family: 'Courier New', sans-serif; 
            font-size: 14px; z-index: 5; pointer-events: none; letter-spacing: 4px; text-transform: uppercase;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <h1 style="font-weight: 100; letter-spacing: 5px;">QUANTUM TREE <span style="font-size:0.5em; vertical-align: super;">V2</span></h1>
        <p style="font-size: 12px; color: #666;">åˆå§‹åŒ–ç²’å­ç³»ç»Ÿ...</p>
    </div>
    <div class="instruction">Open Hand : Stardust &nbsp;|&nbsp; Close Fist : Christmas Tree</div>
    
    <div id="canvas-container"></div>
    <video id="video-element"></video>

<script>
    // --- 1. åœºæ™¯ä¸è§†è§‰ ---
    const scene = new THREE.Scene();
    // é›¾æ•ˆæ›´æ·±é‚ƒï¼Œé»‘è‰²åä¸€ç‚¹ç‚¹è“
    scene.fog = new THREE.FogExp2(0x020205, 0.0025);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 28;
    camera.position.y = 5;
    camera.lookAt(0, 2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½ä¼˜åŒ–
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 2. æ¢¦å¹»ç²’å­ç³»ç»Ÿ ---
    // å¢åŠ ç²’å­æ•°é‡åˆ° 12000ï¼Œè®©å®ƒæ›´ç»†è…»
    const particleCount = 12000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    const treePositions = new Float32Array(particleCount * 3);
    const scatterPositions = new Float32Array(particleCount * 3);

    // è¾…åŠ©å¯¹è±¡ç”¨äºé¢œè‰²è®¡ç®—
    const colorHelper = new THREE.Color();

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        // --- A. æ ‘çš„å½¢æ€ (ä¿®å¤ç‰ˆ) ---
        // æˆ‘ä»¬ä½¿ç”¨å½’ä¸€åŒ–å˜é‡ t (0 åˆ° 1)
        // t = 0 æ˜¯æ ‘åº•ï¼Œt = 1 æ˜¯æ ‘é¡¶
        let t = i / particleCount; 
        
        // 1. é«˜åº¦æ˜ å°„ï¼šä»åº•éƒ¨ -12 åˆ° é¡¶éƒ¨ 12
        const h = -12 + t * 24;
        
        // 2. åŠå¾„æ˜ å°„ï¼šä¸¥æ ¼çš„åœ†é”¥å…¬å¼ã€‚
        // åº•éƒ¨å®½(åŠå¾„9)ï¼Œé¡¶éƒ¨å°–(åŠå¾„0)ã€‚Math.powè®©æ ‘å½¢ç¨å¾®å‘å†…å‡¹ä¸€ç‚¹ï¼Œæ›´ä¼˜é›…
        const baseRadius = 9 * Math.pow((1 - t), 0.8); 
        
        // 3. èºæ—‹è§’åº¦ï¼šéšé«˜åº¦å‰§çƒˆæ—‹è½¬ï¼Œå½¢æˆå±‚çº§æ„Ÿ
        // t * 40 è¡¨ç¤ºæ•´ä¸ªæ ‘å¤§æ¦‚è½¬40åœˆ
        const angle = t * 40 + (Math.random() * 0.5); 
        
        // 4. å¢åŠ ä½“ç§¯æ„Ÿï¼šç²’å­ä¸åªåœ¨è¡¨é¢ï¼Œä¹Ÿåœ¨å†…éƒ¨ä¸€ç‚¹ç‚¹
        // randomRadiusFactor 0.8~1.0ï¼Œè®©æ ‘æè¾¹ç¼˜æœ‰æ¯›ç»’æ„Ÿ
        const r = baseRadius * (0.8 + Math.random() * 0.4);

        treePositions[i3]     = Math.cos(angle) * r; // X
        treePositions[i3 + 1] = h;                   // Y
        treePositions[i3 + 2] = Math.sin(angle) * r; // Z

        // ğŸŒŸ ç‰¹æ®Šå¤„ç†ï¼šæœ€åçš„ 200 ä¸ªç²’å­ä½œä¸ºâ€œæ ‘é¡¶ä¹‹æ˜Ÿâ€
        if (i > particleCount - 200) {
            treePositions[i3]     = (Math.random() - 0.5) * 1.5;
            treePositions[i3 + 1] = 12.5 + Math.random() * 1.5; // åœ¨æ ‘é¡¶æ‚¬æµ®
            treePositions[i3 + 2] = (Math.random() - 0.5) * 1.5;
        }

        // --- B. æ•£ç‚¹å½¢æ€ (é“¶æ²³ç³»æ•ˆæœ) ---
        // æ‰å¹³åŒ–çš„æ¤­åœ†åˆ†å¸ƒï¼Œåƒæ˜Ÿäº‘
        const spreadR = 25 * Math.sqrt(Math.random());
        const spreadAngle = Math.random() * Math.PI * 2;
        
        scatterPositions[i3]     = spreadR * Math.cos(spreadAngle);
        scatterPositions[i3 + 1] = (Math.random() - 0.5) * 5; // Yè½´å‹æ‰
        scatterPositions[i3 + 2] = spreadR * Math.sin(spreadAngle);

        // åˆå§‹ä½ç½®
        positions[i3] = scatterPositions[i3];
        positions[i3 + 1] = scatterPositions[i3 + 1];
        positions[i3 + 2] = scatterPositions[i3 + 2];

        // --- C. æ¢¦å¹»é…è‰² ---
        if (i > particleCount - 200) {
            // æ ‘é¡¶ï¼šçº¯é‡‘/äº®ç™½
            colorHelper.setHSL(0.15, 1.0, 0.8); 
        } else {
            // æ ‘èº«ï¼šæ¸å˜è‰²
            // è‰²ç›¸(Hue): åº•éƒ¨è“ç»¿(0.45) -> é¡¶éƒ¨å«©ç»¿(0.25)
            // äº®åº¦(Lightness): åº•éƒ¨æš—(0.3) -> é¡¶éƒ¨äº®(0.7)
            const hue = 0.45 - (t * 0.2); 
            const lightness = 0.3 + (t * 0.5);
            colorHelper.setHSL(hue, 0.8, lightness);
            
            // éšæœºæ··å…¥ä¸€ç‚¹ç‚¹çº¢è‰²è£…é¥° (5%æ¦‚ç‡)
            if (Math.random() < 0.05) colorHelper.setHex(0xFF3333);
            // éšæœºæ··å…¥ä¸€ç‚¹ç‚¹é‡‘è‰²è£…é¥° (5%æ¦‚ç‡)
            if (Math.random() < 0.05) colorHelper.setHex(0xFFD700);
        }

        colors[i3]     = colorHelper.r;
        colors[i3 + 1] = colorHelper.g;
        colors[i3 + 2] = colorHelper.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.15, // ç²’å­å˜ç»†
        vertexColors: true,
        blending: THREE.AdditiveBlending, // å¼ºå‘å…‰å åŠ 
        depthTest: false, // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œäº§ç”Ÿå…¨æ¯æ„Ÿ
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. äº¤äº’é€»è¾‘ ---
    let targetState = 'SCATTER';
    const videoElement = document.getElementById('video-element');
    const uiLayer = document.getElementById('ui-layer');

    function onResults(results) {
        if(uiLayer.style.display !== 'none' && results.multiHandLandmarks) uiLayer.style.opacity = 0;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let avgDist = 0;

            tips.forEach(idx => {
                const tip = landmarks[idx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                avgDist += d;
            });
            avgDist /= 4;

            // æ¡æ‹³åˆ¤å®š
            if (avgDist < 0.3) {
                targetState = 'TREE';
            } else {
                targetState = 'SCATTER';
            }
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, height: 480
    });
    cameraUtils.start();

    // --- 4. æ¸²æŸ“å¾ªç¯ ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const currentPos = particles.geometry.attributes.position.array;
        
        // åŠ¨æ€å‘¼å¸å‚æ•°
        const breathe = Math.sin(time * 2) * 0.2; // æ ‘çš„å‘¼å¸å¹…åº¦

        for (let i = 0; i < particleCount; i++) {
            const idx = i * 3;
            
            let tx, ty, tz;

            if (targetState === 'TREE') {
                // åŸºç¡€ç›®æ ‡ä½ç½®
                tx = treePositions[idx];
                ty = treePositions[idx+1];
                tz = treePositions[idx+2];
                
                // å¢åŠ ä¸€ç‚¹åŠ¨æ€æ‰°åŠ¨ï¼Œè®©æ ‘çœ‹èµ·æ¥åƒåœ¨é—ªçƒ/å‘¼å¸
                // åªæœ‰åœ¨æ ‘çš„çŠ¶æ€ä¸‹æ‰åº”ç”¨è¿™ä¸ªå¾®å°çš„å‘¼å¸ä½ç§»
                tx *= (1 + breathe * 0.05);
                tz *= (1 + breathe * 0.05);

            } else {
                tx = scatterPositions[idx];
                ty = scatterPositions[idx+1];
                tz = scatterPositions[idx+2];
                
                // æ•£ç‚¹æ¨¡å¼ä¸‹çš„æ¼‚æµ®åŠ¨ç”» (æ¨¡æ‹Ÿæ˜Ÿäº‘æµåŠ¨)
                const drift = 0.05;
                scatterPositions[idx]   += Math.cos(time * 0.5 + i) * drift;
                scatterPositions[idx+1] += Math.sin(time * 0.3 + i) * drift;
                scatterPositions[idx+2] += Math.sin(time * 0.5 + i) * drift;
            }

            // Lerp æ’å€¼ (0.06 çš„ç³»æ•°è®©åŠ¨ä½œç¨å¾®æŸ”å’Œä¸€ç‚¹ï¼Œæ²¡é‚£ä¹ˆç”Ÿç¡¬)
            currentPos[idx]   += (tx - currentPos[idx]) * 0.06;
            currentPos[idx+1] += (ty - currentPos[idx+1]) * 0.06;
            currentPos[idx+2] += (tz - currentPos[idx+2]) * 0.06;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        
        // æ•´ä½“æ—‹è½¬
        if (targetState === 'TREE') {
            particles.rotation.y += 0.005; // æ ‘çŠ¶æ€è½¬å¾—å¿«ä¸€ç‚¹ç‚¹ï¼Œå±•ç¤º3Dæ„Ÿ
        } else {
            particles.rotation.y += 0.001; // æ•£ç‚¹çŠ¶æ€æ…¢æ…¢æ¼‚ç§»
        }

        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
